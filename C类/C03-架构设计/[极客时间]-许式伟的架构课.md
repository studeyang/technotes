> 来源极客时间《许式伟的架构课》--许式伟

# 开篇词 | 怎样成长为优秀的软件架构师？

当我们把程序员类比成建筑师时，按照能力水平来分，我觉得大体可以分为三个层次：搬砖师、工程师、架构师。

- 软件搬砖师之名对应到建筑行业的建筑工人，他们的编程能力和业务基本上停留在堆叠代码，按照要求去实现功能需求的层面。
- 一些有追求的程序员会关注代码的质量。代码质量的评判可以有这样一些基本维度：可阅读性（方便代码流转）、可扩展性 / 可维护性（方便修改功能，添加新功能）、可测试性（质量管理）、可复用性（简化后续功能开发的难度）。这一类致力于不断提升软件代码的工程质量的程序员，我们可以称他们为软件工程师。
- 光靠把控软件工程师的水平，依赖他们自觉保障的工程质量，是远远不够的。软件工程是一项非常复杂的系统工程，它需要依赖一个能够掌控整个工程全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。

是的，掌控全局的前提是：在自己心中去重新构建出整个世界。在这个过程中，你不需要一上来沉浸在某个技术的实现细节（除非它影响了你对这个世界构建过程的理解），但是你知道整个世界的脉络，知道整个世界的骨架。

这个专栏，我基本上围绕着两个脉络主线来展开内容：

- 如何从零开始一步步构建出整个信息世界；
- 在整个信息世界的构建过程中，都用了哪些重要的架构思维范式，以及这些范式如何去运用于你平常的工程实践中。

# ==服务端开发篇==

# 34 | 服务端开发的宏观视角

**服务端程序的需求**

其一是规模。

- 桌面程序是为单个用户服务的，所以它关注点是用户交互体验的不断升级。
- 服务端程序是被所有用户所共享，为所有用户服务的。一台物理的机器资源总归是有限的，能够服务的用户数必然存在上限，所以一个服务端程序在用户规模到达一定程度后，需要分布式化，跑在多台机器上以服务用户。

其二是连续服务时长。

- 桌面程序是为单个用户服务的，用户在单个桌面程序的连续使用时长通常不会太长。
- 服务端程序通常都是 7x24 小时不间断服务的。当用户规模达到一定基数后，每一秒都会有用户在使用它，不存在关闭程序这样的概念。

其三是质量要求。

- 每个桌面程序的实例都是为单个用户服务的，有一亿的用户就有一亿个桌面程序的实例，一个桌面程序实例运行崩溃，它只影响一个用户。
- 服务端程序是很多用户共享使用一个程序实例，一个服务端程序实例崩溃，可能影响几十万甚至几百万的用户。

所以，服务端程序必须是多实例的。单个程序实例的临时不可用状态，要做到用户无感知。

**服务端开发的体系架构**

从宏观视角看，一个服务端程序首先应该是一个多实例的分布式程序。其宏观体系架构示意如下：

![image-20250617231941958](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202506172319915.png)

相比桌面程序而言，服务端程序依赖的基础软件不只是操作系统和编程语言，还多了两类：

- 负载均衡（Load Balance）；
- 数据库或其他形式的存储（DB/Storage）。

# 35 | 流量调度与负载均衡

**什么是 “流量调度”？**

我们首先要了解这样几个常见的服务端程序运行实例（进程）相关的概念：

- 连接数：有时候也会被称为并发数，指的是同时在服务中的请求数。也就是那些已经发送请求（Request），但是还没有收完应答（Response）的请求数量。
- IOPS：指的是平均每秒完成的请求（一问一答）的数量。它可以用来判断服务端程序的做事效率。
- 流量：分为入向流量和出向流量，入向流量 ≈ IOPS `*` 请求包平均大小；出向流量 ≈ IOPS `*` 应答包平均大小。

所谓流量调度，就是把海量客户并发的请求包按特定策略分派到不同的服务端程序实例的过程。有很多手段可以做流量调度。

**1、DNS 流量调度**

最基础的方式，是通过 DNS，如下图所示。

![image-20250619223327872](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202506192233959.png)

一个域名通过 DNS 解析到多个 IP，每个 IP 对应不同的服务端程序实例。这样就完成了流量调度。这里我们没有用到常规意义的负载均衡（Load Balance）软件，但是我们的确完成了流量调度。

那么这种做法有什么不足？

第一个问题，是升级不便。要想升级 IP1 对应的服务端程序实例，必须先把 IP1 从 DNS 解析中去除，等 IP1 这个实例没有流量了，然后我们升级该实例，最后把 IP1 加回 DNS 解析中。

不过 DNS 解析是有层层缓冲的，过了一天可能都还稀稀拉拉有一些用户请求被发送到 IP1 这个实例。假如一个实例升级需要 1 天，我们总共有 10 个实例，那么就需要 10 天。这太夸张了。

第二个问题，是流量调度不均衡。一方面，不是每次用户请求都会对应一次 DNS 解析，客户端自己有缓存。另一方面，DNS 解析本身也有层层缓存，到 DNS 服务器的比例已经很少了。所以在这样情况下，按域名解析做流量调度均衡，是非常粗糙的，实际结果并不可控。

那么，怎么让流量调度能够做到真正均衡？

**2、网络层负载均衡**

负载均衡软件 LVS（Linux Virtual Server）就工作在这一层。我们以 LVS 为代表介绍一下工作原理。

LVS 支持三种调度模式。

- VS/NAT：通过网络地址转换（NAT）技术做调度。请求和响应都会经过调度器中转，性能最差。
- VS/TUN：把请求报文通过 IP 隧道转发至真实服务器，而真实服务器将响应直接返回给客户，调度器只处理请求报文。这种做法性能比 VS/NAT 好很多。
- VS/DR：通过改写请求报文的 MAC 地址，将请求发送到真实服务器，真实服务器将响应直接返回给客户。这种做法相比 VS/TUN 少了 IP 隧道的开销，性能最好。

我们重点介绍下 VS/DR 技术。

![image-20250619223703775](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202506192237819.png)

如上图所示。设客户端的 IP 和 MAC 为 CIP、CMAC。

第 1 步，客户端发起请求，其 IP 报文中，源 IP 为用户的 CIP ，目标 IP 是 VIP；源 MAC 地址为 CMAC ，目标 MAC 地址为 DMAC。

第 2 步，请求包到达 LVS 调度器（Director Server）。我们保持源 IP 和目标 IP 不变，仅仅修改目标 MAC 地址为 RMAC，将请求转发到真实的业务服务器实例 RS（Real Server）。

第 3 步，RS 收到数据包并经过处理，直接响应发送给客户端。

这里面的关键技巧，是 VIP 绑定在多台机器上，所以我们把它叫做虚拟 IP（Virtual IP）。它既绑定在 LVS 调度器（Director Server）上，也绑定在所有的业务服务器实例 RS（Real Server）上。

LVS 这种在网络层底层来做负载均衡，相比其他负载均衡技术来说，其特点是通用性强、性能优势高。但它也有一些缺点，假如某个业务服务器实例 RS 挂掉，但 LVS 调度器（Director Server）还没有感知到，在这个短周期内转发到该实例的请求都会失败，这样的失败只能依赖客户端重试来解决。

有办法避免出现这种请求失败的情况吗？答案是：服务端重试。

**3、应用层负载均衡**

有时候我们也把它叫做应用网关。

当前应用网关，绝大多数都是 HTTP 应用网关。Nginx 和 Apache 都是大家最为耳熟能详的 HTTP 应用网关。HTTP 网关收到一个 HTTP 请求（Request）后，根据一定调度算法把请求转发给后端真实的业务服务器实例 RS（Real Server），收到 RS 的应答（Response）后，再把它转发给客户端。

整个过程的逻辑非常简单，而且重试也非常好做。在发现某个 RS 实例挂了后，HTTP 网关可以将同一个 HTTP 请求（Request）重新发给其他 RS 实例。

为了能够支持重试，HTTP 请求（Request）需要被保存起来。大部分 HTTP 请求不大，直接在内存中存储即可，保存代价不高。但是文件上传型的请求，由于请求包中包含文件内容，可能就需要依赖临时文件或其他手段来保存 HTTP 请求。

**优雅升级**

对于前端是 LVS 这种网络层负载均衡的场景，升级的核心步骤为：

- 通知 LVS 调度器（Director Server），下线掉要升级的业务服务器（Real Server）实例。
- LVS 调度器（Director Server）将该实例从 RS 集合中去除，这样就不再调度新流量到它。
- 要升级的 RS 实例处理完所有处理中的请求，然后主动退出。
- RS 实例更新版本，并重启。
- 将 RS 实例重新加回 RS 集合参与调度。

对于前端是 HTTP 应用网关这种负载均衡的场景，升级的过程可以更加简单：

- 业务服务器（Real Server）实例退出，进入退出状态，这时新请求进来直接拒绝（返回一个特殊的 Status Code）。
- 处理完所有处理中的请求后，RS 实例主动退出。
- 升级系统更新 RS 实例到新版本，并重启。

可以看出，因 HTTP 应用网关支持重试，业务服务器的升级过程就变得简单很多。

# 36 | 业务状态与存储中间件

存储在服务端开发中是什么样的一个地位？今天我们就聊一下有关于存储中间件的那些事情。

![image-20250623221720935](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202506232217012.png)

**业务状态**

首先我们思考一个问题：桌面程序和服务端程序的相似之处在哪里，不同之处又在哪里？

今天让我们从数据的视角来看这个问题。

我们知道，一个桌面程序基本上是由一系列的 “用户交互事件” 所驱动。你可以把它理解为一个状态机：假设在`i`时刻，该桌面程序的状态为业务状态`i`，它收到用户交互事件`i`后，状态变化为业务状态`i+1` 。这个过程示意如下：

> 业务状态`i+1` = F( 用户交互事件`i` ，业务状态`i` )

![image-20250623223049610](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202506232230658.png)

仔细考虑你会发现，其实服务端程序可以用一模一样的模型来看待。只不过它不是由 “用户交互事件” 来驱动，而是由 “网络 API 请求” 所驱动。你同样可以把它理解为一个状态机：假设在 `i` 时刻，该服务端程序的状态为业务状态`i` ，它收到网络 API 请求`i` 后，状态变化为业务状态`i+1`。这个过程示意如下：

> 业务状态`i+1` = F( 网络 API 请求`i` ，业务状态`i` )

![image-20250623223357345](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202506232233387.png)

它们最大的差别是业务状态的表示不同。桌面程序的业务状态是存储在内存中的，桌面程序的 Model 层是一棵 DOM 树，根结点通常叫 Document。这棵 DOM 树其实就是桌面程序的业务状态。

服务端程序的业务状态如何表示？

**存储中间件与容灾级别**

服务端程序的业务状态持久化难度，比桌面程序要高很多。如果我们在某个 API 请求完成并持久化的时候，其他 API 请求如果只能排队等着的话，服务端在用户眼里就停止服务了。

于是，存储中间件就应运而生了。

最早期人们对存储中间件的容灾级别要求并不高。数据库都是单机版本，没有主从。随着互联网的普及，我们对容灾级别这个事情的要求越来越高。

首先，单机数据库是不够的，需要多机相互热备，这就是数据库主从结构的来由。这样我们就不需要担心数据库单机故障会导致服务临时不可访问，甚至出现更严重的数据丢失。

其次，单机存储量终归有上限，这样我们服务的用户数就有上限。在分布式数据库出现之前，人们的解决方案是手工的分库分表。总之，业务上我们需要做到规模可伸缩，不必担心单机物理存储容量的限制。

最后，单机房的可靠性也是不够的，机房可能会出现网络中断，极端情况下还可能因为自然灾害，比如地震，导致整个机房的数据丢失。于是就出现了“两地三中心”，跨机房容灾的数据灾备方案。

**存储即数据结构**

存储中间件是什么？存储中间件就是 “元数据结构”。

对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。今天我们接触的存储中间件有哪些？

- 键值存储（KV-Storage）；
- 对象存储（Object Storage）；
- 数据库（Database）；
- 消息队列（MQ）；
- 倒排索引（SearchEngine）；
- 等等。

目前看，存储中间件的种类是不可枚举的。

# 37 | 键值存储与数据库

今天我们来聊一下应用最为广泛的存储中间件：数据库。

**数据库的种类**

第一类是关系型数据库（Relational Database），以 MySQL、Oracle、SQLSever 为代表。这类数据库把数据每个条目（row）的数据分成多个项目（column），如果某个项目比较复杂，从数据结构角度来说是一个结构体，那么就搞一个新的表（table）来存储它，在主表只存储一个 ID 来引用。

第二类是文档型数据库（Document Database），以 MongoDB 为代表。这类数据库把数据每个条目（row）称为文档（document），每个文档用 JSON 或其他文档描述格式表示。

第三类是键值存储（KV Storage），以 Cassandra 为代表。键值存储从使用的角度来说，可以认为是数据库的特例。数据库往往是允许设定多个索引字段的，而键值存储明确只有唯一索引。

**事务**

无论是何种数据库，都面临一个重大选择：是否支持事务。事务就是把一系列数据库操作变成原子操作的能力。展开来说，事务的特性我们往往简称为 ACID：

- 原子性（Atomicity）：在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。
- 一致性（Consistency）：事务的执行必须保证系统的一致性。
- 隔离性（Isolation）：事务与事务之间不会互相影响。
- 持久性（Durability）：一旦事务完成了，那么事务对数据所做的变更就完全保存在了数据库中。

一种常见的事务实现方式是乐观锁。常规的锁是先互斥，再修改数据。但乐观锁不同，它是先计算出所有修改的数据，然后最后一步统一提交修改。提交时会进行冲突检查，如果没有冲突，那么提交会成功。否则就是发生了冲突，会放弃本次修改。

这意味着，每个数据有可能有多个值。如下：KEYi -> [(VER0, VAL0), (VER1, VAL1), …]。其中，VER0 对应当前已经提交的值 VAL0，VER1 对应事务1 中修改后的值 VAL1。

在事务提交的时候，锁住整个数据库（前面修改过程事务间不冲突，所以不需要锁数据库），检查所有记录的读条件，如果这些读条件对应的条目（row）的已提交版本都`<=`基版本（VER0），那么说明不冲突，于是提交该事务所有的修改并释放锁。

如果事务提交的时候发现和其他已提交事务冲突，则放弃该事务，对所有修改进行回滚（其实是删除该事务产生的版本修改记录）。

**主从结构**

一旦我们考虑数据库的业务可用性，我们就需要考虑多副本存储数据。当我们数据存在多个副本时，就有数据一致性的问题。因为不同副本的数据可能值不一样，我们到底应该听谁的。

解决这个问题的方法之一是采用主从（Master-Slave）结构。主从结构采用的是一主多从模式，所有写操作都发往主（Master），所有从（Slave）都从主这边同步数据修改的操作。这样，从（Slave）的数据版本只可能因为同步还没有完成，导致版本会比较旧，而不会出现比主（Master）还新的情况。

从（Slave）可以帮主（Master）分担一定的读压力。只有那些纯粹用于界面呈现用途，而不是用于逻辑计算的场景（比如财务场景）能够接受读旧版本数据，可以从从节点读。

从（Slave）最重要的是和主（Master）形成了互备关系。在主挂掉的时候，某个从节点可以替代成为新的主节点。

**分布式**

多副本让数据库的可用性和持久性有了保障，但是仍然有这样一些问题需要解决：

- 数据规模大到一定程度后，单个物理节点存放不了那么大的数据量；
- 主承受的读写压力太大，单台主节点承受不了这样高的 IOPS（吞吐能力）。

怎么解决？答案是分布式。简单说，就是把数据分片存储到多台设备上的分片服务器一起构成一个单副本的数据库。分片的方式常见的有两种：

- 哈希分片（Hash based sharding）；
- 范围分片（Range based sharding）。

在分布式存储领域，有一个著名（CAP）理论。其中，C、A、P 分别代表一个我们要追求的目标。

- 数据一致性 (Consistency)：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据；
- 服务可用性 (Availability)：所有读写请求在一定时间内得到响应；
- 分区容错性 (Partition-tolerance)

假设我们不会放弃服务的可用性（A），那么分布式存储就要在数据一致性（C）和分区容错性（P）之间取舍。

数据一致性（C）的选择基本上是业务特性决定的，业务要求是强一致，我们就不可能用最终一致性模型，相应的，我们只能在分区容错性（P）上去取舍。









