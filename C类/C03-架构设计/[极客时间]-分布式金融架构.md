> 来源极客时间《分布式金融架构课》

# 开篇词 | 如何成为金融级人才？

军用软件的复杂度在于需要实时处理武器信号，操作系统的复杂度在于需要在功能的多样性和效率之间做一个良好的平衡，而金融软件的复杂度在于如何在软件系统的演进过程中保持并证明系统的正确性。

那到底什么是金融级软件呢？

首先，我们得知道金融软件要解决的核心问题是什么？没错，就是钱！钱一旦处理错了，那可就是真金白银的损失，所以任何一家金融机构对系统错误都是零容忍的。这样的特殊性，使得金融级软件系统区别于很多其它的大型软件系统，它对正确性以及速度都提出了更高的要求。

那面对这样的金融级软件，金融级人才又需要怎样的能力呢？

假如你现在是一个金融系统的负责人，你需要在系统正确性和吞吐量之间做个选择。很显然你会毫不犹豫地选择正确性。但是如果有人告诉你，系统吞吐量出现了问题，用户可能就转不了钱了，这样会造成恶意挤兑，从而形成恶性群体性事件。那么你又该如何选择呢？你很有可能会进退维谷，在两难之间犹豫。

其实这个例子就反映了我们对金融软件质量的要求。衡量软件质量有很多种不同角度，一般的软件我们会选择在矛盾中取舍，但是金融软件则要求我们尽可能在所有的地方都做到最好。这种在矛盾中同时追求极致的要求，就是对金融级人才最大的挑战。这也是你进阶资深架构师乃至公司技术决策者的必经之路。

**这门课是怎么设计的？**

我是从对事和对人这两个角度来设计课程的。

对事的角度比较简单。我希望你能在学完所有课程之后，对金融行业需要怎样的系统建立一个比较全面的认识，知道系统里都包括哪些重要组成部分，以及每个部分的技术挑战点在哪里，常见的技术解决方案都有哪些。最重要的是，你会掌握金融软件架构的整体思路，知道都有可能出现哪些矛盾，以及出现这些矛盾的时候你都有哪些选择。

对人的角度比较困难，也是我个人的一些期许。在这短短的二十多讲里，我会带你初步了解金融业务为什么会有这么多分类，金融软件究竟解决的是什么业务问题，金融软件系统是怎么一步步发展到现在这个样子的。还有最重要的一点，我会为你剖析上述问题的本质究竟是什么。

为了帮助你循序渐进地学习，我把这个专栏分为 3 大部分。

第一部分，金融与业务系统。

这部分我们将围绕常见的金融业务生态及其系统架构需求进行讲解，重点包括第三方支付、交易所、券商、银行和投资银行等等。搞懂了这些金融机构和业务的特点，我们还要总结共性和技术逻辑，给你分析如何利用领域驱动设计的思想来更好地解决金融软件的复杂度问题。

第二部分，系统的正确性保障。

了解了金融业务以后，我们就可以对金融软件质量提出要求了。这部分我们重点学习如何保证金融系统架构的正确性，具体包括业务处理的正确性以及数据处理的正确性，它们是金融系统的必选项。最后，我还会讲到系统优化，让你在保证系统高正确性的同时，也能合理追求速度。

第三部分，分布式正确性及高可用。

针对复杂系统一定是重在实践的，所以这部分我会以分布式系统环境为背景，重点讨论分布式一致性的存在条件、分布式共识算法、分布式的事件溯源架构、分布式数据方案的设计原理以及数据系统的实时动态分库等等。

这部分的每节课都是线上环境中会遇到的关键问题。学习难度逐渐升级，结合实际案例，寻找问题本质，落地前面所学。另外，我还会分享一个金融领域绕不开的话题——容灾，重点讲解跨机房实时容灾以及如何提高系统稳定性。

![image-20250212222717967](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502122227690.png)

# ==第一部分，金融业务与系统 (6讲)==

# 01 | 业务初探：扫了二维码之后发生了什么？

![image-20250212222717967](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502122227690.png)

**情景假设**

扫码支付其实也分很多场景，我选择了与跨境电商相关的扫码跨境支付场景，具体的假设有这些：

1. 付款方用户支付的是人民币。
2. 付款方的借记卡是国内银行 A 发行的，简称买家开户行。
3. 第三方支付公司的备付金账户在国内银行 B，简称第三方开户行。
4. 收款方接受的是美元。
5. 收款方的借记卡是国外银行 C 发行的，简称卖家开户行。
6. 第三方公司是通过银行 D 进行外币兑换业务，简称汇兑提供行。

那么接下来，我会分 4 个部分给你讲解整个支付过程：用户扫码支付、第三方公司进行本币代收、外汇交易以及外币代付。

**用户扫码**

从终端用户的角度来看，扫码由鉴权、支付和拉取状态三个步骤组成。接下来，我们就来详细看看这几个步骤。

- 鉴权

扫码支付最终会用买家的银行卡进行支付。在你开始扫码支付之前，第三方公司需要核实你是否有这张卡的使用权，俗称“绑卡”。

我们可以把鉴权的过程分为 4 步：第 1 步，用户填写【姓名/身份证号/银行卡号】和手机号码；第 2 步，银行发短信验证码给用户手机号；第 3 步，用户将【姓名/身份证号/银行卡号】和短信验证码发给第三方支付公司；第 4 步，第三方支付公司再将所有信息发送给银行进行确认。

在用户绑卡通过之后，银行会返回给第三方支付公司这个用户的内部 ID 信息（也叫 Token）。之后第三方支付公司就可以拿这个 ID 进行所有合法的操作。

刚才给你讲解的流程示意图如下：

![image-20250213230805936](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502132308022.png)

- 支付

为了应对用户操作的峰值情况，金融机构普遍通过异步消息处理的架构来对极端流量进行削峰填谷。如果流量突然增大，异步消息架构会缓存所有请求，慢慢处理。异步消息架构的结果就是用户不会及时得到处理结果，需要自己不断地去查询处理情况。

当银行处理完支付后，银行会把支付成功的消息推送给用户和第三方支付公司。第三方支付公司也会推送给你支付成功的消息。

![image-20250213231249275](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502132312316.png)

**本币代收**

前面我们假设了这笔支付涉及到外汇交易，由于买家的和卖家使用的币种不同，就无法直接转账。这时候就需要第三方支付公司这个中间人来帮忙了。中间人角色要做 3 件事情：

1. 本币代收
2. 外汇交易
3. 外币代付

通俗一点来说，本币代收就是将你该付的钱先打到第三方支付公司账上。由于第三方支付公司的账号和买家的银行卡在两家不同的银行，本币代收需要进行跨行转账。

- 央行和清算机构

所有银行都在这个新的第三方机构里放足够多的钱，一般叫做==存款准备金==。当两家银行之间需要转账的时候，第三方机构在内部搬运一下就好。

怎么知道转移的金额有多少？银行系统对跨行转账的流程进行了优化。那就是在白天只做记录，不进行任何实质性的跨行转账。等每天结束的时候计算一下两个银行之间交易金额的差额是多少，最后通过央行进行一笔跨行转账就可以了。这种计算交易差额的方式叫做==轧差==。

- 跨行转账流程

第一步，第三方支付公司发送指令给第三方开户行，要求将钱从用户的买家开户行转到第三方开户行。

第二步，第三方支付公司拥有用户在买家开户行的 Token，所以可以合法发起这笔转账。跨行转账流程开始。

第四步，买家开户行记录的结果是对用户的账号进行扣款。扣款结束后用短信的方式通知用户。

第五步，第三方开户行记录的结果是对第三方支付公司的账号进行打款。

第六步，到了晚上，清算机构对白天发生的交易进行盘存，发现有一笔从买家开户行到第三方开户行的跨行转账还没有真正完成。清算机构会将这笔未完成的跨行转账信息发送给央行。

最后一步，央行收到信息之后，将买家开户行在央行的存款准备金调低，并将第三方开户行在央行的存款准备金调高。

![image-20250213232339873](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502132323936.png)

**外汇交易**

外汇交易的过程又是怎样的呢？按照交易量的大小，可以分为 C 端外汇零售业务和 B端外汇批发业务两个部分。

- C 端外汇零售业务

当第三方支付公司完成了用户的本币代扣之后，第三方支付公司账上就有了对应的人民币。接下来的一步是将这些人民币变成美元，这样才能将美元转给国外的卖家。

在这节课的最开始，我假设了第三方支付公司是通过汇兑提供行进行外汇交易的。那么第三方公司需要在汇兑提供行里建两个账号，一个人民币账号和一个美元账号。同时，汇兑提供行内部也需要有对应两个币种的账号，一个对应着人民币资金池，另一个则是美元资金池。

所以，一笔外币的购买涉及到 4 个账号之间的 2 笔支付订单。交易过程的示意图如下：

![image-20250214223657496](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502142236592.png)

讲到这里，我们解决了第三方支付公司美元账户不足的问题，但是它用来购汇的人民币账户一直在往外出钱，总会有枯竭的一天，又该怎么办呢。

所以我们还需要考虑从外部调资金进来。由于第三方支付公司的备付金账户在第三方开户行，因此需要做从第三方开户行到汇兑提供行的跨行转账，示意图如下：

![image-20250214223941698](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502142239197.png)

但是第三方公司在第三方开户行的账户也在一直出钱，我们往上推演一步，就会发现第三方开户行账户也需要有进来资金的渠道。这个是由前面我们提到的本币代收的过程实现的。我们把买家出资的流程补充完整。整个过程的示意图如下：

![image-20250214224054223](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502142240260.png)

- B 端外汇批发业务

外汇市场是按照交易量大小来划分层次的。最底层的是面对终端用户的外汇零售商。这些零售商负责给一般用户提供小额的外汇交易。这些小笔的外汇交易汇集在一起之后，就会形成一笔大的外汇订单，然后继续往上层交易。

和底层的外汇零售商一样，上一层的机构将所有外汇交易汇集在一起之后，形成更大的外汇订单，再往更上一层交易。一直往上汇集这种事情不会永无止境地进行下去。这个流程的尽头是全球最大的外汇做市商，一般是巨型的跨国商业银行。

![image-20250214224832672](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502142249760.png)

# 02 | 原理解读：第三方支付的业务逻辑和系统组件？

![image-20250212222717967](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502122227690.png)

接下来我们先搞懂支付涉及的核心金融原理，然后按照架构由简到难的顺序，逐步学习点券系统、支付系统和第三方支付公司的支付系统。这样你就能理解支付系统是如何遵循核心金融原理，一步一步从简单的几个组件发展到全面的系统架构了。

**信息流与资金流分离**

在支付业务中最核心的概念是信息流与资金流分离。那什么是信息流和资金流呢？用一句话来概括，信息流指的是想象中钱的流转过程，资金流指的是钱的实际流转过程。

**点券系统**

顾名思义，点券系统就是管理点券的系统。因为重点是讲解架构原理，所以在这里对点券业务和系统做一些简化。现在我们假设只有代金券这一种点券，而且你只能使用代金券来购买产品。

假设最开始用户 A 拥有 100 元代金券，用户 B 拥有 10 元代金券。那么在购买后，用户 A 的代金券账号需要减少 10 元的代金券，同时用户 B 的代金券账号需要增加 10 元的代金券。

好了，到目前为止，我们可以看到，支付过程至少需要 3 个系统：

1. 业务系统，负责生成交易订单和支付订单；
2. 支付网关，负责处理支付订单；
3. 账务系统，负责维护用户账户情况。

在用代金券支付完成后，用户可能需要检查自己的代金券余额，以及与代金券相关的账单。所以我们还需要一个查询系统来完成相关的查询。

另外从产品体验角度看，现在的系统还有一点不足：用户 B 并不知道自己账户收到了点券。这时候及时通知用户 B 可能是一个更合适的产品设计。这时还需要一个账户变动的通知系统。通知系统通常采用异步通知的方式。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502152301472.png" alt="image-20250215230101423" style="zoom: 67%;" />

**支付系统**

现实中，绝大多数支付业务场景是资金流和信息流不一致的情况。所以你必须知道，什么样的架构系统，才能处理好信息流与资金流不一致的情况。

假设用户 A 用 10 元钱从用户 B 那里购买一支笔。这次用户 A用银行卡付款，而不是用点券。

和点券系统一样，业务系统还是照例发起一笔支付订单给支付网关：用户 A 将银行卡上的10 元转给用户 B。不同点在于，支付网关在收到这笔支付订单后，需要判断支付系统能否独立完成资产的转移。点券这种内部资产是可以内部解决的，但是银行卡属于用户，是外部资产，支付系统不能自主解决。

所以支付网关还需要实现路由能力，将内部资产和外部资产两种操作，分发给不同的资产处理组件。因此，这里我们还需要增加内部和外部资产管理系统两个组件，如下图所示。

![image-20250215230741675](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502152307717.png)

外部资产管理系统需要对接第三方支付公司来完成银行卡转账业务。这个对接任务通过金融网关来实现。金融网关主要是实现二进制协议的对接，比如证书签名、加解密、协议传输、数据校验等。

需要注意的是，金融网关和第三方支付公司之间走的是异步通讯协议。前面讲过，异步通讯有额外的不确定状态。那架构上应该如何处理呢？异步系统对接时的架构设计原则，需要将同步系统的一次调用拆分成三个步骤：异步调用、轮询和对账。

![image-20250215231403817](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502152314864.png)

**第三方支付系统**

电商公司会通过支付系统将信息流交给第三方支付系统处理。第三方支付系统会将这个信息流再转交给银行处理。在做跨境交易的时候我们甚至还能看到不同国家第三方支付公司之间的彼此合作。

这里我重点讲三点不同，分别是流量支持、资金池和清算系统。

- 系统的流量支持

第三方支付公司有很多家客户，有可能会面临非常大的支付流量。举个例子，比如第三方支付公司负责代发工资或者代缴水电费，一到月底就会面临非常大的流量。

所以第三方支付公司需要有能力处理这种常见的互联网应用高并发问题。比如我们前面提到的异步消息处理，就能削峰填谷，降低峰值流量的压力。

如果流量再高，还可以选择熔断降流等手段来进行服务降级。如果存储能力支撑不了这么高流量，还可以使用各种不同的缓存技术降低查询操作对数据库的压力，或者使用分库分表的方式来进一步降低每个数据库上面的压力。

- 备付金资金池

资金池是一种常见的用户资金管理手段。资金池就是将属于用户的钱都放在一个大的池子里。池子里的钱不分你我，你是将资金池看作一个整体来操作的。但是你还留着一个账本，上面记载了每个人原来在资金池里放了多少钱。这样虽然钱是混在一起，但是账面上是清楚的。

跨行转账需要多家银行之间配合，还可能需要支付一定的跨行交易费用。但是如果第三方支付公司在每家银行都有资金池，就可以直接在两家银行内部完成用户资金和资金池资金之间的操作了。

![image-20250215231930192](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502152319248.png)

- 清结算能力

清结算中心处理的是多家银行之间的跨行转账。当第三方支付公司有了多个资金池之后，这些资金池之间的转账关系其实和跨行转账一样。既然是一样的，那么第三方支付公司有没有可能做一些清算公司的事情，从而进一步降低交易成本呢？

的确如此。所以成熟的第三方支付公司内部都会有一个自己的清算中心。这个清算中心把自己当作一个外人，对资金池之间的转账交易进行清结算工作。这里要注意清算中心的结算过程涉及到资金流操作，需要通过内部支付网关来操作外部资金。

![image-20250215232110778](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502152321824.png)

**总结**

![image-20250215224942198](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502152249613.png)

# 03 | 产品大观：不同金融业务都有哪些技术实现要点？

这节课我和你聊一聊不同的金融业务都有哪些技术实现要点。

金融行业赚钱的方法有很多种，但是最核心的原理只有一个，那就是利用信息不对称赚钱。接下来我会带你了解常见的金融业务以及它们需要的技术。

**信贷类业务**

- 传统信贷业务

信贷业务俗称放贷，传统的银行主要从事的就是这个业务。信贷类业务的表现形式有很多，比如有面向企业的贷款，或者给你的房贷，以及 P2P，花呗、借呗、白条等等。

下面这幅图展示了银行通过信贷业务赚钱的过程：

![image-20250217222545832](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502172225877.png)

银行需要解决这个信息不对称问题来防止亏欠。毕竟不亏钱就是赚钱。所以传统银行需要通过收集数据来评价借款人的还款能力，也就是借款人的信用评级。

对于系统架构来说，信贷业务的特点是交易频率低，而且用户评级在短时间内不会发生大的变化，因此整个系统架构不需要实时组件，常用的批处理、大数据处理框架都能很好地发挥作用。

- 次贷危机后的信贷业务

你的银行定息存折是可以抵押给银行，然后再贷款的呢？这个过程就是资产证券化。

2008 年发生的次贷危机就是用个人的房贷来抵押贷款。简单的抵押赚不了多少钱，所以有一些聪明人把一大堆房贷打个大包，然后按照信用评级拆分成几个小包。类似的小包还可以堆在一起，然后再继续拆分，最后再将拆分好的小包卖给投资人。房贷总量虽然没变，但是分分拆拆之后总价值反而增加了很多，这样金融公司就能躺着赚钱了。

![image-20250217220704527](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502172207621.png)

现在常见的 P2P、花呗、借呗和白条等，背后大多都是这种资本运作方式，只不过它们将资产证券化的资产从房贷换成了个人消费贷。

**交易类业务**

交易类业务其实是一个非常巨大的隐形的金融市场，一般人很难了解全貌。那我们就来看看典型的交易类业务都有哪些。

==第一，场内交易==

在交易所内的交易叫作场内交易，交易的场所就是交易所。

- 交易所角度

市指这家公司的股票可以在股票交易所内交易。稍微学术一点来说，上市就是股票在二级市场交易。由于二级市场是个公开市场，靠大量的交易来解决价格信息不对称问题，而不是靠人脉关系。这时候就对信息系统有很高的要求。

一级市场的信息不对称主要体现在如何匹配大额股票的买家和卖家。投资银行解决信息不对称的方式是通过公司和自己的人脉来撮合买卖双方。由于解决方案是靠人而不是靠技术，所以这一阶段对信息系统要求不高。

- 交易所技术

从事过开发工作的人都知道软件处理很难实现微秒级延时，就算达到这个延时了系统吞吐量也上不去。但是股票交易所确确实实既有低延时又有高吞吐量。那它是怎么做到的呢？

答案很简单，就是用硬件，比如用 FPGA 来实现。

交易所的主要功能是撮合买方和卖方。当一个新的订单进来的时候，交易所会查看能不能成交。如果不能成交就等待下一笔订单。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502172244471.png" alt="image-20250217224437417" style="zoom:67%;" />

- 交易所用户角度

如果你和我一样是个股票小散户的话，在股市上是掀不起多大风浪的。但是如果你掌管了一家大型机构，机构里每次买卖都是上亿的资金，那很有可能会影响到市场价格。也就是说会让你买得更贵，或者卖得更便宜。那怎样才能避免这种情况呢？

这时候，投资银行或者券商会给你提供一个拆单的服务。他们会将你的大订单拆成很多小订单，并且选择在不同的时间发送到股票交易所，这样就不会产生剧烈的市场波动。这意味着投资银行需要有一个算法交易平台。这个平台需要实时对市场数据进行分析，用算法来拆解和执行订单。

- 交易所用户技术

交易所用户都很关心系统延时。那么延时究竟需要有多低呢？一般来说，机构用户要求系统的消息处理时间在毫秒和微秒之间（1/1000～1/1000000 秒）。那这么低的延时会怎么影响系统架构呢？

首先影响的是编程语言的选择。一般来说 C 是首选，核心代码用汇编语言实现。要求不高的地方用 C++ 也可以。至于互联网常见的编程语言，比如 Java、Go、Python、Javascript 等，都不适合。

其次影响了软件架构，系统会用单个进程来完成所有的事情，最好不要有网络开销。如果交易所允许，金融公司还会出钱将机器放在交易所的机房内。这样就能进一步缩短光的传输距离，节省宝贵的数据传输时间。

==第二，场外交易==

股票市场和其它的场内交易只是金融市场的冰山一角。绝大部分的金融交易都发生在交易所外，也叫场外交易。

- 金融产品

场外交易的金融产品类型非常广。如果你想私下交易股票，这个行为也属于场外交易。外汇交易虽然和股票市场类似，但是外汇交易没有交易所，也属于场外交易。你平时听过的花呗、借呗、白条、P2P、供应链金融等，一旦它们被资产证券化，也属于场外交易。那这些场外交易产品，它们对于信息系统又有什么要求呢？

- 合同定价与市场风险计算

前面提到过，交易所的一个功能是发现价格。人们通过在公开市场交易来消除价格信息的不对称。那场外交易没有交易所，又该怎么发现价格呢？

既然你在场外交易的时候没法被动地发现价格，那么就只能主动发现价格了。所以对于场外交易的金融产品来说，你需要独立计算出合同的价格。定价系统需要处理复杂度和数据量的问题，这一点也是对所有场外交易定价系统的要求。

**小结**

![image-20250217222039257](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502172220301.png)

# 04 | 领域驱动设计（上）：如何设计金融软件顶层架构？

接下来我会从三个角度入手，带你理解领域驱动设计理论中的核心知识点。

**领域驱动设计侧重点**

从空间上来讲，它看到的是整个行业或者整个领域。从时间上来讲，它看到的是软件从发生、发展到消亡的整个生命周期。从角色上来讲，它看到的是业务、产品、开发和运维等所有参与人员的合作。

虽然领域驱动设计是从宏观角度解决问题，但是它非常务实，主要体现在以下两个方面，一方面是注重投资回报比（Return On Investment，ROI），另一方面是做长期优化。

==1、注重投资回报比==

具体来说，适合使用领域驱动设计的系统需要具备这些特点：

- 系统组件足够多。
- 业务逻辑足够复杂。
- 软件生命周期长。

总之一句话，简单问题不要用领域驱动设计。金融软件恰好满足了上面三个要求，因此它也是一个领域驱动设计的标志性应用场景。

==2、长期优化==

你也许听过一些国外的真实故事，讲的是金融系统完成开发之后，毫无问题地运行了几十年。当它突然出了问题时，还需要把早已经退休的开发人员反聘回来解决。这些故事告诉我们，金融系统可能会存在很久，可能所有最初的相关人员都已经去做其他项目了，这个系统还需要有人继续维护。

领域驱动设计尝试解决这些长期沟通问题，降低整个软件生命周期中的沟通成本，这样就能降低项目失败的可能性。

我们在解决问题的时候一般顺序是先搞定人，再做事。所以接下来我们先看看怎么设计人员组织架构，然后再考虑怎么设计系统组织架构。

**人员组织架构**

我们都知道，软件开发过程中涉及到三类人，第一类是业务方；第二类就是系统分析人员，包括产品经理和架构师；还有一类是系统开发人员。相应地，软件开发流程有 4 个步骤：

1. 业务方提出需求。
2. 产品经理分析需求。
3. 架构师根据产品经理的分析做出合理的架构设计。
4. 开发人员按照产品文档和架构设计文档来进行开发。

当开发人员发现文档细节不够全面，甚至内容有误怎么办呢？这时候，沟通只能原路返回，等产品或者业务方再次确定清楚后，再从上往下传递消息。由于每一步沟通都会造成信息损失，沟通的流程越长，信息损失越大。

领域驱动模型提了一个根本的解决方案。既然沟通的流程长了会丢失信息，那么最优化的沟通方式不就是只有一个层级的沟通吗？所以领域驱动设计取消了常见的垂直沟通方式，变成小组沟通方式。每次沟通都是所有相关人员参与。

![image-20250220224324709](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502202245899.png)

这个沟通过程中，会沉淀下来对专业术语的共同理解，这就是领域语言（Domain Language）。有了领域语言之后，各方的沟通再也不是鸡同鸭讲，而是永远在一个频道上。

总结一下：领域驱动设计建议软件的所有参与方之间能以小组的形式进行直接沟通。开发要懂业务，业务方和产品也要懂技术。沟通的结果是形成一个大家都能认同和理解的领域语言。

**系统组织架构**

人的问题解决了，我们再来看看怎么解决事情。领域驱动设计提供了一个分解问题的思路。领域驱动设计将所有业务领域划分为三大类型：核心领域、通用领域以及支持型领域。不同领域有不同的处理态度。那我们来逐一讲解一下每个类型的划分标准。

==1、核心领域==

上世纪 70 年代股票交易量大增。当时一台大型计算机的价格简直就是天价。一些有远见的金融公司花了巨额资金，买了这些计算机来处理股票交易记录。很快，没这么做的人就因为无法处理大量交易而淡出市场。他们退出不是因为业务方向错误，而是因为在没有计算机辅助的情况下，服务质量下降。这时候的金融行业的核心竞争力就是电算化，股票交易处理就是核心业务领域，交易清结算组件就是核心组件。

到了 21 世纪初，衍生品定价模型逐渐成熟了，谁计算金融风险的速度越快，结果越准确，谁的盈利就会越高。在 08 年经济危机的时候，有的金融公司计算风险的速度快，就能提前逃离市场。如果你计算得慢，就得被迫吞下有毒资产。这时候的金融行业的竞争优势就是风险的计算和对冲，风险计算就是核心业务领域，风险计算组件就是核心组件。

所以，你可以这样理解，一个业务是否是核心业务，取决于它是否能给公司带来行业内的竞争优势。我结合自己的经验，给你梳理了核心领域的三个要点，分别是资源分配、审时度势以及宏观视角。

- 资源分配

核心竞争力是买不来的。所以核心领域所对应的软件组件一般建议自研。同时我建议你把公司最好的人手放在核心领域的开发项目组中，这就是好钢用在刀刃上。另外，由于核心竞争力需要不断升级，你还要做好长期维护的准备。

- 审时度势

金融行业的玩家都是聪明人，所以一家公司的核心竞争力是瞒不住的。稍微过段时间就会有人学会你的赚钱之道，这时候你们之间的竞争就变成了公平竞争，你就再也没有核心竞争力了。

所以在金融行业，我们想判断核心领域，就需要合理判断此时此刻公司所处的行业位置，在可预见的未来对手会如何应对，以及自己应该如何针对性地升级业务和系统。

- 宏观视角

怎么宏观地判断一个核心领域呢？这就要看它能不能给你带来超额利润。超额利润是一个经济学的名词，表示超出一般行业水平的利润。比如对券商来说，能不能发短信通知给用户其实对盈利水平的影响不大。但是如果能提高用户下单的速度，那就完全不一样了。

==2、通用领域==

顾名思义，通用领域是可以在不同行业通用的领域。比如我们前面提到的短信平台，不只是金融公司可以使用，物流公司也可以使用。类似的还有安全、日志、存储等等。

领域驱动设计强调投资回报比，所以当市场上存在多个类似的产品的话，我们要尽量采购相关服务或者产品，而不是自己研发。同时你也不要对软件质量做过多的要求。这时候要本着能用就行的心态，研发系统的时候也按随时能替换的方式去设计。

==3、支持型领域==

支撑型领域是那些用来辅助核心领域正常运行的领域。支持型领域并非核心竞争力，但是缺了之后也无法正常开展业务。比如说会计系统、市场数据系统等等，一般属于支持型领域。

支持型领域和通用领域很容易搞混。支持型领域一般并不会跨行业通用，顶多只在金融行业内通用。

==4、领域分析举例==

假设你有一天成为了有钱人，需要有人帮你打点一下财产。这时候金融公司会给你提供资
管服务，替你理财。

首先，你需要在系统中记录有兴趣购买的衍生品。因为衍生品是一种有完整生命周期的金融合同，所以系统需要有一个金融合同的==生命周期管理系统==。其次，你在挑选金融产品的时候需要知道这个产品的价格，如果价格低就买。这就是定价和报价环节。这个环节开始的时候，你需要对合同价格有自己的判断，这就要用到==定价系统==。

接着就到了合同签订和打印的步骤。金融合同的签订其实是一个交易过程，就需要有==交易系统==。衍生品交易涉及到的金额特别巨大，因此很多人都不太信任电子合同。合同签订之后还需要打印存档，这就需要有==打印系统==。

投前的步骤在合同确认之后就结束了。接下来就需要你自己管理合同了。这时一般要注意这几个事项。

第一，金融合同签订以后，买卖双方需要履行合同义务，也就是按照合同声明的金额进行资金往来，因此需要有==支付系统==和==会计系统==。

第二，资金转账通常不能在节假日进行，所以需要==日期系统==来通知系统自动调整日期。

第三，你需要随时知道自己的资产有多少，风险有多大，这里需要有==风险计算系统==。

接下来我们来做个练习，看看如何将每个部分划分到正确的领域。

我们先来看看哪几个是核心领域。你做资产管理是为了获得合理的收益，所以核心业务应该和金融产品的收益相关。这里我们发现有两个系统组件比较相关，分别是定价和风险计算系统，所以这两个属于核心领域。

至于打印、支付、会计、日期变更等都是常见功能。除了金融行业，很多其他行业也有，所以这些都是通用功能，属于通用领域。

但是相对而言，交易、报价和生命周期管理没那么通用，但是也不属于核心竞争力，因此这些都属于支持型领域。下面这幅图展示了我们划分下来的结果：

![image-20250220230324036](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502202303086.png)

**小结**

![image-20250220222828199](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502202228288.png)

# 05 | 领域驱动设计（下）：如何设计统一的金融业务模型？

这节课我想和你聊一聊怎么设计统一的金融模型。

**金融业务背景假设**

我们在第 3 节课里给你说到了很多金融业务。其中交易类业务和场内交易业务都相对简单。所以我们如果想要找复杂的例子，就需要定位在场外交易的产品类型。场外交易最简单的类型就是期权（Option），所以我们可以选择债券期权（Bond Option）这个金融业务的例子。

如果这时候期权价格比市场价低，你可以用低的期权价格来购买债券，同时以更高的价格卖出去，这样一买一卖就能马上获利。当然了，你也可以选择买了债券之后不卖出去。这时候你就拥有了这个债券。债券的发行人会定期给你利息，比如半年一次或者一年一次。

期权给你的选择权力可以让你永赚不赔。金融行业都是聪明人，这么好的事情显然不可能是免费的。你需要花钱来买债券期权，所以债券期权本身是有价格的。由于不知道未来债券价格会怎么波动，所以我们只能根据自己对各种未来概率的假设来估算债券期权的价格。这个估算的过程就是==债券期权的定价过程==。如果你认为的债券期权的真正价格比券商卖的要高，就可以从券商那里买入这个债券期权。

定价过程有两个最重要的输入，一个是债券的所有未来现金流，另一个是债券价格的历史数据。还有一些比较重要的数据，比如无风险利率和债券发行方的信用数据等，我们都归类于市场数据。

我们举例的债券期权其实是叫看涨期权（Call Option），类似的还有看跌期权（Put Option）。只能在到期日行权的期权类型叫作欧式期权（European Option），类似的还有美式期权（American Option）。

**建模逻辑**

1、实体（Entity）

实体是具有唯一标识符的业务对象。你可以用唯一标识符来区分不同的业务对象。如果你见过债券的话，会发现它和人民币很像，都是在角落里印上一串数字。这个就是债券的唯一标识符。债券期权虽然是一个纯电子合同，但是它也有唯一标识。对开发人员来说，唯一标识符就是一串字符串，比如 UUID。

债券和债券期权这两个实体有一个共同点，它们都不会凭空产生和消失。它们都有一个日期叫作发行日期，这就是它们出现的一天。它们也有到期日期。金融合同在发行日期和到期日期之间，还会规定一些其他的资金行为。我们把金融合同从产生到消失的整个过程叫作生命周期。另外，这个金融合同我们会通过唯一标识符进行管理。

我们总结一下，实体有这样两个特点：

- 有唯一标识符（用唯一标识符来判断是否是同一个实体）
- 有生命周期管理

期权对应了一个未来可能的资金流（Optional Cashflow），这个资金流会不会发生取决于你是否行权。这个可能的资金流也是实体。债券的资金流（Cashflow）相对来说比较确定，也是实体。债券现金流是由债券利息（Interest）构成的，这个利息也是实体。

我们把所有的实体和它们之间的引用关系画出来就是下面这张图：

![image-20250222231156817](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502222311881.png)

2、值对象（Value Object）

顾名思义，值对象里的“对象”就是面向对象编程（OOP）里的对象（Object），“值”表示这个对象里只有值，没有其他东西。

我们来看一个具体的值对象例子。金融合同一定会规定合同涉及到的金额（Notional）。金额就是一个值对象。金额本身由币种（Currency）和数额（Amount）两个信息组成。如果一个金额是 100 元人民币，而另一个金额也是 100 元人民币，我们会说这两个金额相等。因为我们在判断金额是否相等的时候并没有用到任何唯一标识符，这说明了值对象并不是由唯一标识符决定的，而是由它内部的组成内容决定的。所以当我们判断两个值对象是否相等时，只能比较值对象内容。

前面讲的债券期权例子中也有几个值对象。前面提到的金额是一种。还有期权行权的日期和行权方式。我们再仔细分析的话，会发现行权日期里的日期也属于值对象。我们把值对象加上之后的示意图如下：

![image-20250222231716589](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502222317650.png)

另外还有一些和债券期权没有直接关系的市场数据也是值对象，比如无风险市场利率。市场利率的示意图如下：

![image-20250222232443510](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502222324569.png)

这里我给你梳理一下，值对象有这些特点：

- 没有唯一标识符，有内部属性，通过比较内部属性来判断是否相等。
- 不可修改。修改会返回新的值对象。
- 不能独立存在，是其他实体或者值对象的附属品。

3、领域服务（Domain Service）

领域服务其实就是这个领域相关的服务。在债券期权的例子中，买卖合同时的定价（Pricing）过程是一个领域服务，合同的风险计算（Risk Calculation）也属于领域服务。我们把领域服务补全之后的示意图如下：

![image-20250222232353439](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502222324946.png)

**生命周期管理**

我们在前面说过实体是有生命周期的，我们需要对生命周期进行管理。但是通常生命周期管理不是以单个实体为粒度进行管理的。实体之间存在着非常复杂的引用关系，彼此之间形成了一个引用关系图。如果你对引用关系图中的任何一个实体节点进行操作，势必会影响到周边的实体节点。

1、聚合（Aggregate）

如果你不考虑这些被影响的周边实体节点，那么整个系统的状态会变得不一致。一个办法是对影响的范围做一个划分。这个划分就是聚合。聚合规定了一个影响范围的边界。它有一个唯一入口叫作聚合根（Aggregation Root）。聚合根一定是一个实体，通过它可以访问到所有跟它相关的其他实体或者值对象。

比如开头例子的债券期权（Bond Option），它就是一个聚合根。通过它可以访问到债券起源合同的其他内容。债券期权的聚合和聚合根示意图如下：

![image-20250222233312589](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502222333648.png)

聚合里面所有内容需要在一个数据库事务内操作。

我们前面只提到了聚合的边界，但是没有说边界究竟有多大。其实大和小没有统一标准，需要具体情况具体分析。一般来说你要注意这 3 点：

- 聚合里节点的关系尽量形成有向无环图。
- 聚合的关系图尽量小一点。这样数据库事务小，存取速度快。
- 聚合的关系图如果太大的话，需要做一些优化。一般采用延时访问（Lazy Loading）的方法。当你访问聚合根的时候，系统并没有将所有内容从数据库加载进来，等访问到具体内容的时候才会加载。这样就能摊销数据加载时间，也可以节省不必要的数据库访问。

2、多个聚合

前面提到过，聚合是引用关系图的一个子图。当你把所有聚合划分好之后，会发现聚合之间也是存在引用关系的。

单个聚合只能通过聚合根来访问聚合内的元素。一个聚合的内部节点也能访问另一个聚合的聚合根，甚至可以将聚合根的唯一标识符作为值对象存储下来。债券是期权的底层资产，因此期权这个实体需要能访问债券这个实体。体现在架构图上，就是在债券期权这个聚合内部，有节点可以访问债券这个聚合根。示意图如下：

![image-20250222234231052](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502222342116.png)

**小结**

![image-20250222224800810](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502222248909.png)

# ==第二部分，系统的正确性保障==

# 06 | 计算输入的正确性：怎么选择正确时间的数据？

但是领域驱动设计只是从顶层设计来分析应该怎么做金融系统。我们在这个模块会重点解决怎么做才能达到金融系统的最重要的要求：正确性。

正确的数据是所有正确性的基础。那让我们来一起看看怎么解决正确性的第一个问题：怎么选择正确时间的数据。

**业务举例**

在国外有一种金融机构叫作养老基金，大家平时交的养老保险有时候就是养老基金在负责处理。由于养老基金的收益是在你退休之后才能获得，所以养老基金一个最重要的衡量指标就是，这个基金未来能不能给你足够的生活费用，即养老基金每年的收益率能不能超过每年生活费用的涨幅。

生活费的涨幅一般用通货膨胀率（CPI，Consumer Price Index）来表示。通货膨胀率每个月都会公布，它就是一个数字而已，这是一个比较简单的金融市场数据。但是它的特点在于数据公布时间特别晚。当前只能公布一个现在通货膨胀率的预期值。真正的值可能要几个月之后才能公布，而且之后还有可能会修改。

比如下面这张图的例子里，我们公布了两份数据，分别是 2018 年 3 月和 6 月的通货膨胀率。2018 年 3 月的数据是一个月之后公布的，在 3 个月之后和 1 年之后又公布了两次修改。6 月份的数据也类似。

![image-20250224221124669](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242211781.png)

那问题来了。上面这个例子里公布了 5 次共 2 个数据，每次公布的数据都不一样。你怎么确保每次数据的更新都不会影响前面已经完成的金融业务呢？

你需要让业务、运营、财务、合规等所有部门的信息系统都用统一的数据访问方式。这种数据访问方式还需要可重现。不管是过了多少年，系统更新换代了多少次，开发人员换了多少批，你都能正确地知道过去发生了什么。这也是我们这节课叫作“正确时间”的原因。

既然我们要找到一个能满足金融公司所有部门的长期的数据使用方案，那么这个方案一定要和金融数据的核心原理相关。在金融系统里这个解决方案叫作双时序数据库。

**如何理解双时序数据库？**

==1、双时序坐标轴==

从前面的通货膨胀率的例子你可以看到，一个金融数据会有两个时间，一个是数据对应的业务发生时间，一个是数据的修改时间。在双时序数据库里这两个时间分别叫作发生时间和记录时间。

既然存在双时序数据库，那么一定还有单时序数据库。你平常见到的时序数据库其实就是单时序数据库。这两者的区别在于，单时序数据库解决的是数据增加问题，双时序数据库解决的是数据修改问题。

==2、数据可见范围==

那根据前面的例子，我们在 2018 年 4 月收到了一个月前的通货膨胀率的数据。这个数据对应了坐标系的一个点，坐标为（2018 年 4 月，2018 年 3 月）。画出来就是下面这个样子：

![image-20250224221648812](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242216879.png)

你会发现，上面图中这个坐标系里有一个粉红色的方块。这个方块表示了数据的在系统内的可见范围。下面这幅图表示了 4 种查询范围。其中在粉红色方块的查询能查到数据，其余 3 个都查不到数据。你可以感受一下具体的查询过程：

![image-20250224221721730](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242217792.png)

==3、可见范围的覆盖==

根据假设，在 3 个月之后的 2018 年 7 月，收到了一个月前的通货膨胀数据。这时候坐标系在（2018 年 7 月，2018 年 6 月）多了第二个点。我们将这两个点的可见范围画出来就是下面这幅图的样子：

![image-20250224221819573](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242218634.png)

可以看出来，第二个点加入之后新增了一块蓝色的矩形区域，覆盖了原来矩形的右上角。还是按照之前对可见范围的定义，不同颜色的区域表示了你能看到的具体是哪个数据。

所以如果你查询用的两个时间点的坐标刚好在蓝色区域时，看到的就是 2018 年 7 月新增的通货膨胀率数据，如果你的点坐标在粉红色区域时，看到的就是 2018 年 4 月增加的数据，就像下面这幅图表示的一样：

![image-20250224221838257](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242218332.png)

==4、可见范围的正确定义==

假设又过去了 2 个月。在 2018 年 9 月的时候，机构更正了 2018 年 3 月的通货膨胀率，也就是更正了我们录入的第一个数据。这是我们坐标系的第三个点。你会发现这第三个数据和第一个数据的发生时间都是一样的，但是记录时间差了半年。下图展示了第三个数据加上去之后，各个数据的可见范围：

![image-20250224225141353](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242251426.png)

当我们在做数据查询的时候，我们关心的是离当前查询时间点最近的合理数据。这里的“合理”指的是数据既存在，且有意义；最近”指的是当有多个数据都是合理的时候，选择发生时间最晚的数据。

比如在金融业务中我们经常会问到现在的股价是多少，或者现在的利率是多少。由于金融数据的变化永远是离散的，而不是连续的，所以并不存在一个时间叫“现在”。当你问现在是多少，其实从逻辑上来讲，你问的是离现在最近的数据是多少。所以当你在双时序数据库查询的时候，你表达的意思是当你坐上“时间机器“返回到查询所对应的记录时间，然后查询在发生时间点以前就已经生效的所有数据之中，哪个数据离你最近。

当我们解释完最终版的可见范围之后，你就能理解为什么下面这幅图查询到的是第 2 个数据，而不是第 3 个数据，而且为什么第 3 个数据的可见范围只有一小部分。

![image-20250224225930139](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242259532.png)

**优缺点分析**

说到这里，你应该已经了解双时序数据库的基本原理和使用方法了。在我们实际应用之前，还需要知道它的优缺点，这样你才能设计之初就会有个合理判断。

==1、优点==

双时序数据库最大的优点是数据的不变性。没有特殊要求的情况下，金融行业要求数据不可被覆盖和篡改，这种业务需求决定了系统数据一定要具有不变性。

另一个优点是数据的唯一性。所有数据都有唯一标识符，也就是数据对应的记录时间和发生时间。所有数据的可见范围也可以由这个数据的唯一标识符来唯一决定。

那回到我们开头提的第一个问题，你怎么才能知道 30 年前养老保险涉及到的所有数据？当你用合同定制时间作为记录时间和发生时间，就能查询到 30 年前这个合同用到的所有数据。之后的修改一定不会影响你查询的结果。

==2、缺点==

双时序数据库的第一个缺点是学习成本高。以往处理数据的时候都只有一个时间，现在变成了两个时间。所有开发人员都需要了解二维情况下的数据可见范围。有时候我们跟业务方和产品经理沟通，也会发现他们也需要用双时序数据来定义自己的数据使用规则。这些都是很高的教育成本。

双时序数据库的另一个缺点是执行速度慢。和时序数据库相比，双时序数据库多了一个维度的时间，所以需要多加一个索引。这个额外的索引在数据插入和查询时候都会消耗额外的时间，因此不太适合于延时要求非常高的使用场景。

虽然双时序数据库的学习成本和使用成本都不低，但是作为整个公司层面的数据正确性框架来说，它能让所有人深入理解数据的时间本质，从框架层面排除了不正确的使用方式，从而降低出错的可能性。从长期来看，有十年磨一剑的功效。

**理论与实际的区别**

我们在最开始介绍双时序数据库的可见范围时，没有说过发生时间的可见范围有多大。所以可见范围默认是一直可见的。但是理论上并没有这个假设。理论上数据的可见范围可以是有限的。

拿房贷举个例子。房贷最长时间是 30 年，所以 30 年以后房贷合同就无效了，也就是房贷合同的可见范围只有 30 年。这意味着在双时序数据库里，你的房贷合同的可见范围是一个高度为 30 年的矩形，看起来应该是下图这个样子：

![image-20250224230729299](https://technotes.oss-cn-shenzhen.aliyuncs.com/2024/202502242307373.png)







# ==第三部分，分布式正确性及高可用==















