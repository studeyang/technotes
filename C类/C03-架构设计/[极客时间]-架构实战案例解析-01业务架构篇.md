> 来源：极客时间《架构实战案例解析》 --王庆友

# 开篇词

**我是如何规划这个课程的？**

我将整体内容划分为业务架构和技术架构两大部分，先理论后案例，带你深入理解每种架构要解决的问题，以及如何解决。

- 业务架构篇：重点针对系统的扩展性和复用性两大目标展开。每部分都有三个实际案例，让你理解如何以服务化和平台化的方式升级改造系统，最终实现扩展性和复用性的目标。
- 技术架构篇：重点针对系统高可用和高性能 / 可伸缩的目标展开。每个目标都有 3 个实际案例，让你理解如何在项目中，灵活应用这些策略和原则。

# 01 | 架构的本质：如何打造一个有序的系统？

**架构的本质**

架构的本质是：通过合理的内部编排，保证复杂系统高度有序，能够不断扩展，满足业务和技术的变化。这里包含两层意思，我们具体展开说下：

- 通过内部调整，保证复杂系统有序

首先，架构的出发点是业务和技术不断复杂化，引起系统混乱，从而需要通过架构来保证有序。

> 搭一个草房子很简单，可以直接上手；
>
> 盖一个 2 层楼房，稍微复杂一些，但在工匠的经验 指导下，问题也不大；
>
> 而盖一座高楼，复杂性就大不一样了，我们需要考虑内部结构、承重、采光、排水、防雷抗震等，这就需要专业人员事先做好整体的架构设计，并严格地按照设计来施工。

可以看到，建筑里的架构不是天然就有的，而是因为建筑越来越复杂，我们需要通过架构来管理这种复杂性，避免建造过程的失控。

软件系统也是如此，从简单的桌面应用发展到现在的大型互联网平台，这个过程中，系统规模越来越大，业务和技术也越来越复杂。我们同样需要通过架构设计，消化复杂性带来的混乱，使系统始终处于一个有序状态，能够应对现有和将来的需求变化。

- 内部编排保证有序

其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。

“分”就是把系统拆分为各个子系统、模块、组件。我们比较熟悉的微服务架构，就是一种典型的拆分做法。

“合”就是基于业务流程和技术手段，把各个组件有机整合在一起。比如说在微服务架构中，拆分为具体微服务后，我们需要对这些服务进行归类和分层。

> 举个例子，在 Builder 设计模式中，它的主逻辑是将各个部件组装起来，它不关心创建某个具体部件的内部逻辑，它承担的是合的部分；工厂模式负责细粒度的构造逻辑，承担的是分的部分。大家各自管理自己的复杂性。

**架构的分类**

可以分为业务架构、应用架构和技术架构。<!--通常有很多种分法，这只是其中一种。-->那么，这些架构分别为谁服务，解决什么问题？一个系统的落地，首先需要人来开发，然后由机器来运行，人和机器共同参与一个系统的落地。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210720233258.png" alt="image-20210720233257939" style="zoom:50%;" />

人可能会遇到的问题：业务太复杂，系统后续维护困难；架构追求的是系统概念清晰，业务逻辑容易理解，从而使人可以直观地进行代码开发。

机器可能会遇到的问题：外部请求并发量太大，机器扛不住；架构要求的是系统能够水平扩展，支持硬件容错，保证系统的高性能和高可用。

这里，开发的痛点主要由业务架构和应用架构来解决，机器的痛点主要由技术架构来解决。

- 业务架构

业务架构就是讲清楚核心业务的处理过程，定义各个业务模块的相互关系，它从概念层面帮助我们理解系统面临哪些问题以及如何处理；

- 应用架构

应用架构就是讲清楚系统内部是怎么组织的，有哪些应用，相互间是怎么调用的，它从逻辑层面帮助我们理解系统内部是如何分工与协作的。

- 技术架构

技术架构就是讲清楚系统由哪些硬件、操作系统和中间件组成，它们是如何和我们开发的应用一起配合，应对各种异常情况，保持系统的稳定可用。它从物理层面帮助我们理解系统是如何构造的，以及如何解决稳定性的问题。

> 举一个电商的例子。
>
> 比如一个商品业务，可能对应 3 个应用，一个前台商品展示应用、一个后台商品管理应用，以及一个商品基础服务。
>
> 业务架构定义了一个下单的具体流程；应用架构定义了下单有哪些应用参与以及它们如何协作；技术架构要保障相关的应用能够处理高并发，从而保证业务顺利进行。

> 举一个拍电影的例子。
>
> 业务架构定义了这个电影的故事情节和场景安排；应用架构定义了有哪些角色及其职责，在每个场景中，这些角色是如何互动的；技术架构确定这些角色由谁来表演，物理场景上是怎么布置的，以此保证整个拍摄能够顺利完成。

**什么是好的架构？**

一个好的架构必须满足两方面挑战：业务复杂性和技术复杂性。

- 业务复杂性

系统架构首先要满足当前的业务需求，还要满足将来的业务需求，系统要能不断地扩展变化，包括调整现有功能，以及增加新功能。（扩展性）

而且，系统的功能变化不能影响现有业务，不要牵一发动全身。因此，在架构设计上，要做到系统的柔性可扩展，能够根据业务变化做灵活的调整。（扩展性）

此外，上新业务功能，需要短时间就能落地。因此，架构设计上，还要做到系统功能的可复用，这样才能通过快速复用，实现业务敏捷和创新。（可复用）

- 技术复杂性

要保证一个业务能正常运行，还要保证这个系统稳定可用。

一个复杂系统是由很多部分组成的，如应用程序、服务器、数据库、网络、中间件等，都可能会出问题。那怎么在出问题时，能够快速恢复系统或者让备用系统顶上去呢?（高可用）

还有流量问题，平时流量不大，少量机器就可以处理，但在大促的时候，大量流量进来，系统是不是能够通过简单地加机器方式就能支持呢?（高并发）

此外还有低成本的问题，系统能否做到，使用廉价设备而不是高大上的 IOE 设备，使用免费的开源组件而不是昂贵的商业套件，使用虚拟化技术而不是物理机。（低成本）

**什么是好的架构师？**

一个优秀的架构师，应具备很强的综合能力。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210720225454.png" alt="image-20210720225454505" style="zoom:50%;" />

- 抽象思维

抽象思维是架构师最重要的能力，架构师要善于把实物概念化并归类。比如，面对一个大型的 B2C 网站，能够迅速抽象为采购 -> 运营 -> 前台搜索 -> 下单 -> 履单这几大模块，对系统分而治之。

- 透过问题看本质

透过问题看本质是由事物的表象到实质，往深层次挖掘。比如，看到一段 Java 代码，知道它在 JVM 中如何执行；一个跨网络调用，知道数据是如何通过各种介质（比如网卡端口）到达目标位置。

- 多领域知识和技术前瞻性

架构师要有技术的广度（多领域知识）和深度（技术前瞻）。对主流公司的系统设计非常了解，知道优劣长短，碰到实际问题，很快就能提供多种方案供评估。

- 沟通交流

能落地的架构才是好架构，架构师还需要具备良好的沟通能力，能确保各方对架构达成共识，愿意采取一致的行动。

- 平衡取舍

良好的平衡取舍能力，可以确保架构在现有资源约束下是最合理的，能让理想最终照进现实。

# 02 | 业务架构：作为开发，你真的了解业务吗？

我们知道，项目的开发都是从收集业务需求开始的，原始的需求一般来自于最终用户。但是，每个用户其实只清楚自己所负责的那部分，因此这些原始需求往往是零散的，特别是当一个业务流程跨多个部门的时候，更没有一个人能够说清楚这个业务的全貌。

所以说，仅仅基于这些原始的需求来指导开发是远远不够的，这时，就需要产品经理和架构师介入进来，填补这段空白。

**产品经理的职责**

产品经理的职责就是：告诉用户，系统长什么样子；告诉开发，他要实现什么功能。

具体需要做什么呢？

1、梳理出业务流程：首先，收集用户的原始需求，然后，将它们梳理成一个个业务流程<!--业务流程包括输入、输出和业务功能-->。比如说，一个典型的购物流程，包括商品浏览、商品加入购物车、下单、支付等步骤。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210722231720.png" alt="image-20210722231719861" style="zoom:67%;" />

其中，下单步骤的输入，就是订单的各种信息，下单的功能，就是整合这些信息，创建一个具体的订单，而下单的输出结果，就是新创建的订单。

2、定义用户界面：把每个步骤具体化为页面原型。在原型中，会直观的给出各个步骤的输入或输出，以及用户的操作过程，最后再把这些页面串起来，形成一个业务流程。

产品经理定义了系统的外表，把大量零散的原始需求经过梳理和关联，变成一系列有序的业务流程。这些产出已经足够让用户知道，系统长什么样子了。但对于开发者来说，要实现什么功能？这些还远远不够，因为他们需要能进一步看到系统的内部结构。

而这一步，就是业务架构师要做的事情。

**业务架构师的职责**

我们设计一个购物流程模块，里面包含商品查询、添加购物车、下单和支付接口，来分别对应流程里的 4 个业务步骤。以这样的方式构建系统，表面上看起来，业务和系统的映射好像非常简单，但在实际中，落地的难度却非常大。

难点一：掌握不同模块的业务和数据模型。比如说要实现一个小小的购物流程模块，就要同时涉及商品、购物车、下单和支付四个业务，模块的开发者要同时非常清楚这四部分的数据模型和业务逻辑。

难点二：业务改动难度大。如果一个业务领域的需求发生了变化，比如说，订单要增加一个新的状态，那么所有涉及该订单的模块都要知道这个变化，并要做出相应的调整。这就要求，每个开发者都是全知全能的，对所有业务都了如指掌。

那面对这样的业务，我们通常有哪些落地方法？

方法一：按业务流程来拆分业务。先把所有的业务流程拆散，这样得到了一堆业务节点；然后把业务节点进行归类，相关的业务节点放在同一个系统模块里。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210723000411.png" alt="image-20210723000411735" style="zoom: 67%;" />

这种按照业务流程来拆分系统模块，对应关系比较直接，但实现起来很困难。<!--因为流程的条数是更难控制的，很容易陷入面向过程开发。-->

方法二：按业务域来拆分业务。在实际业务场景中，一个业务节点可能会涉及不同业务领域的功能。

比如说，一个下单节点，会涉及到获取商品信息、获取用户信息、扣库存、下订单等多个业务功能，那么你就可以进一步分解这个节点的功能，把不同的功能分到对应的业务域和系统模块。

基于业务域，构建了系统模块后，我们就可以按照这样的方式还原整个业务流程，比如上面的购物流程例子，我们就可以这样还原它：

```text
购物流程 = 商品模块.商品搜索 + 购物车模块.添加商品 + 订单模块.创建订单 + 支付模块.支付
```

如果你把这个定义画成序列图，就很直观和容易理解，也比较符合开发人员思维，系统实现起来非常容易。通过这种系统模块之间的不同功能组合，我们很容易给出各个业务流程的定义。

至此，我们对业务架构师应该有一个认识了。

业务架构师的工作，就是把业务流程和节点打散，按照业务域的维度来划分系统模块，并定义这些模块之间的关系，最终形成一个高度结构化的模块体系。这样，开发人员既容易理解业务，又方便落地系统。

> 产品经理和业务架构师的工作既有区别又有联系，简单地说，产品经理定义了系统的外观，满足了用户；
>
> 业务架构师在此基础上，进一步定义了系统的内部模块结构，满足了开发人员。

**架构目标之一：业务的可扩展**

业务的主题是变化和创新，系统的主题是稳定和可靠。那么，我们如何才能实现业务的快速变化和系统的相对稳定呢?

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210723230556.png" alt="image-20210723230556719" style="zoom: 67%;" />

我们把业务平台和业务线剥离开。业务平台封装基础通用的功能，这样，它就变得相当地稳定；各个业务线包含自己的个性化需求，业务线只依赖业务平台，业务线彼此之间互相独立，可以自由变化。这样的业务架构设计，就同时保证了系统的相对稳定和业务的快速创新。

支付宝就是采用了这样业务架构，来看一下它的演变过程。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210723231158.png" alt="image-20210723231158201" style="zoom:67%;" />

一代系统架构中，前台的业务和后台的业务直接耦合，形成了多对多的网状结构，如果修改一个后台业务线，就会影响到很多前台业务线；如果增加一条新的前台业务线，需要同时和很多后台业务线对接，这样的架构无疑是对业务的扩展非常不利的。

二代系统架构中，在前后台业务线之间，构建了独立的支付清算平台，从而实现了前台业务和后台业务的解耦。不管前台业务，还是后台业务，都只需要对接中间的支付清算平台，而业务线之间相互不影响，这样的方式，自然可以很好地支持业务扩展。

**架构目标之二：业务的可复用**

业务架构设计如何实现业务的可复用呢?

在业务架构设计中，如果基于业务流程来定义系统模块，那么，这样的系统模块很难在不同业务场景中复用。因为业务场景是经常变化的，这就导致系统模块也是经常变化。

正确的做法是按照业务域来划分业务，把业务流程中的节点拆分到各个业务域，按照业务域来构造系统模块。业务域是相对固定的，它有明确的数据模型和业务规则，这样一来，系统模块也就比较固定和通用，也就具备比较好的复用基础。

要想实现高复用，业务架构对系统模块的定义，还有更多的要求。

- 模块的职责定位要非常清晰。对于模块来说，在定位范围内的职责要全部涵盖到，而不在这个范围的职责全部不要。
- 模块的数据模型和接口设计要保证通用。架构师需要归纳业务场景，通过抽象提炼， 形成通用化的设计，以此来满足多个类似场景的需求。
- 做好业务的层次划分。越是底层的业务，它就越相对固定，所以，在做高复用设计时，我们可以尝试把一个业务域按照层次拆分得更细。

> 举个例子，同样是订单业务域，对于底层订单的增删改查功能，不同类型的订单都是一样的，但对于上层的订单生命周期管理，外卖订单和堂食订单可能就不一样。
>
> 把订单模块拆分为多个上层订单模块和一个基础订单模块，这样，基础订单模块对于所有类型的订单，都能够提供复用。

# 03 | 可扩展架构：如何打造一个柔性的系统？

什么样的系统才能具备良好的扩展能力？系统内部是有明确结构的，它可以简化表达为：系统 = 模块 + 关系。

**模块**

如何定义模块？

模块是系统的基本组成部分，它泛指子系统、应用、服务或功能模块。模块内部由数据和业务逻辑组成，其中数据是核心，业务逻辑围绕着数据，对数据做进一步加工，方便外部使用。

如何划分模块？

原则一：从扩展性的角度，我们对模块的要求是---定位明确，概念完整。

每个模块要有明确的定位，它的核心职责是什么。在具体划分模块职责的时候，可以从业务、数据和功能三个角度划分。业务上，要保证模块业务概念的完整性；数据上，模块要覆盖对应业务领域的全部数据。

比如一个订单模块，它要覆盖所有渠道的订单，包括三方平台的订单、自有商城的订单、线下门店的订单等，这些不同类型订单的数据模型和实际数据，都由订单模块负责。

功能上，模块要包含业务领域的全部功能，比如订单模块包含所有订单相关的功能，包括订单数据的增删改查、订单业务规则校验、订单的状态和生命周期管理等。

原则二：模块还要---自成体系，粒度适中。

模块的业务逻辑尽量围绕自身内部数据进行处理，对外部依赖越小，模块的封装性越好，稳定性也越强。

模块的粒度要保持适中，不能为了追求定位清晰，把粒度划分得很小，导致系统的碎片化。

> 比如系统早期的时候，一般我们把积分功能放到用户模块里面，不单独构建积分模块，如果后续积分的概念越来越突出，承载的业务越来越复杂，到时候可以把积分功能分离出来，单独成模块。

**依赖关系**

依赖关系的定义？

关系指模块之间的依赖关系，简单地讲，就是模块之间的调用关系，我们知道，调用区分发起方和服务方，因此，依赖关系是有方向性的。

如何定义依赖关系？

原则一：简化依赖方向。

首先，我们希望模块之间的依赖是单向的，尽量避免相互调用。为什么单向更好呢？模块依赖关系越直观体现业务流程，越能帮助人理解，否则，我们会被双向的依赖箭头绕的晕头转向，很难通过模块之间的依赖关系还原实际业务的处理过程。

原则二：减少依赖的数量。

其次，我们要尽量把网状结构转化为层次结构，模块结构层次化是简化模块依赖关系的有力手段。

具体做法就是，我们按照模块定位的不同，把模块划分为不同层次。这样，一个层通过把多个模块组织在一起，就形成了概念上更大粒度的模块，我们理解业务时，关注这个更大粒度的层就可以。依赖关系也只要指向这个层，这样，从理解业务的角度，依赖的数量大幅度地减少了。

MVC 定义的依赖关系就遵循了上述原则。系统模块按照定位，分为表示层（View层）、应用层（Control层）、聚合服务层（Model加强层）、基础服务层（Model层）。<!--聚合服务层，如果系统业务比较复杂，经常需要单独的聚合服务层负责业务流程的编排组合，这个属于 Model 层的加强。-->

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210725231046.png" alt="image-20210725231045992" style="zoom:67%;" />

**打造可扩展的模块体系：模块拆分**

如何打造一个合理的模块体系?

具体的架构手段就是按照业务对系统进行拆分和整合：通过拆分，实现模块划分；通过整合，优化模块依赖关系。

接下来，我们以一个在线出行公司为例，它有出租车、快车和顺风车 3 条业务线，来具体看下如何为它打造合理的模块体系。

我们先对系统进行模块化拆分，拆分有两种方式：水平拆分和垂直拆分。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210726232227.png" alt="image-20210726232226977" style="zoom:67%;" />

- 水平拆分

如何进行水平拆分？

水平拆分是指从上到下把系统分为多层。比如，整个叫车过程，我们可以分为 UI 展现、地图搜索、运力调度和订单支付等几个环节，这是根据系统的处理过程进行划分的。

水平拆分的优点：

1. 功能内聚。通过水平拆分，可以使每一块职责都比较明确，每个模块管理自己内部的复杂性；
2. 模块之间相互松耦合。一个模块的修改不影响另一个模块，比如地图搜索模块中改变了优先路径的推荐，不会影响运力调度模块中的人车匹配算法。
3. 现有业务可做深度扩展。当业务有变化时，系统在特定层做调整，对其他层影响有限，这样把变化局限在一个小范围。

- 垂直拆分

如何进行垂直拆分？

垂直拆分指的是按照不同的业务线拆分，比如，将整个出行业务分为出租车业务、快车业务和顺风车业务，让每个业务都自成体系，形成自己的业务闭环。

垂直拆分的优点：

1. 降低了整个系统的复杂性。通过垂直拆分，一个复杂的出行场景拆分为了几个具体的场景，我们可以根据各个业务线的特点去设计系统。
2. 现有业务可做广度扩展。比如说增加一条新的业务线，可以按照这个思路落地系统。

一般做业务架构时，我们先考虑垂直拆分，从大方向上，把不同业务给区分清楚，然后再针对具体业务，按照业务处理流程进行水平拆分。

**打造可扩展的模块体系：模块整合**

系统拆完后，接下来就是模块整合的工作，整合也有两种好的手段：通用化和平台化。

- 通用化整合

通用化指的是通过抽象设计，让一个模块具备通用的能力，能够替代多个类似功能的模块。

如何进行通用化整合？

回到刚才的出行平台，我们发现 3 条业务线都有地图搜索、运力调度、订单支付这些模块，不同的业务线之间，这些同名的模块逻辑高度类似，只是细节方面有差别。那么我们可以对这些类似的模块进行抽象化处理，整合成一个通用的模块。

我们可以在模块接口中，通过输入参数标识调用来自哪个业务，是出租车、快车还是顺风车，然后在模块内部，针对不同业务线的差异化部分做针对性处理。

通用化整合的优点：

1. 为多个业务线提供了复用。可能这个通用模块增加 5% 的逻辑，但避免了 95% 的重复逻辑。当新的业务线进来，很可能这个通用化的模块，就已经提供了现成的支持。
2. 模块的数量减少了，模块的定位更清晰，概念更完整，职责更聚焦。

在实践中，当不同业务线对某个功能需求比较类似时，我们经常会使用这个手段。

- 平台化整合

平台化是把定位相同的模块组织在一起，以组团的方式对外提供服务。对于外部系统来说，我们可以把这些模块看成是一个整体，一起对业务场景提供全面的支撑。

如何进行平台化整合？

如下图所示，我们可以看到，地图搜索、运力调度、订单支付，都是各个业务线都需要的基础和通用的业务能力，当我们增加新的业务线时，还是离不开这些基础能力。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2021/images/20210725232113.png" alt="image-20210725232113498" style="zoom:67%;" />

所以，我们可以把这些基础模块放在同一层，构成一个基础业务平台。之前，它们是一个个离散的服务，独立地输出能力，现在变成一个大的业务平台，可以提供整体的能力输出。

平台化整合的优点：

1. 我们对多个业务模块进行包装，形成更大粒度的抽象，相当于减少了模块的数量；
2. 作为平台，它的定位更明确，系统依赖关系也更清晰；
3. 新的业务线进来，它可以基于业务平台快速落地；

业务平台化是模块依赖关系层次化的一个特例，只是它偏向于基础能力，在实践中，当业务线很多，业务规则很复杂时，我们经常把底层业务能力抽取出来，进行平台化处理。

# 04 | 可扩展架构案例（一）：电商平台架构是如何演变的？

这里，我总结了国内电商平台架构发展的大致过程，你可以结合图片参考下。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202203312304037.png" alt="image-20220331230450907" style="zoom:67%;" />

**单体架构**

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202203312309151.png" style="zoom:67%;" />

单体架构中的模块只是在逻辑上独立，并没有在物理上严格分开，导致系统在落地时，模块的职责和边界划分比较随意，相应地，模块之间的依赖关系也比较模糊。

当业务系统的体量变大时，单体架构的弊端就充分暴露出来了，我们就需要对系统进行有效的拆分，比如把首页、搜索页、详情页、结算页拆成一个个独立的应用，分别进行管理。于是，分布式架构就应运而生了。

**分布式架构**

分布式架构包括了多个应用，每个应用分别负责不同的业务线，当一个应用需要另一个应用的功能时，会通过 API 接口进行调用。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062213163.png" alt="image-20220406221340946" style="zoom:67%;" />

由于自身业务的需求，引起底层的业务逻辑修改，这时会同时影响 API 接口功能，导致其他业务受影响；另外，在分布式架构下，每个应用都是从头到尾，自搭一套完整的体系，导致业务之间重复造轮子，造成资源浪费。

**SOA 架构**

随着业务的发展，企业需要打通不同系统的信息，每个系统首先把外部需要的能力，封装为一个个粗粒度的接口，传统的 SOA 架构如下图所示。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062216920.png" alt="image-20220406221613847" style="zoom:67%;" />

ESB 负责管理所有调用过程的技术复杂性，包括服务的注册和路由、各种通信协议的支持等等。

新的 SOA 架构是利用服务共享的思想，解决系统的重复开发问题。新的 SOA 架构如下图所示。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062218388.png" alt="image-20220406221849322" style="zoom:50%;" />

针对核心代码重复这种情况，我们可以通过服务化手段，把通用的逻辑和数据从各个业务系统里抽取出来，封装成独立的服务，提供给所有业务进行共享。

**微服务架构**

和 SOA 架构不同的是，微服务是去中心化的，不需要 SOA 架构中 ESB 的集中管理方式。

一个有序的层次化微服务体系如下图所示。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062222650.png" alt="image-20220406222241559" style="zoom:67%;" />

# 05 | 可扩展架构案例（二）：App服务端架构是如何升级的？

本节内容我会通过一个 1 号店 App 服务端架构改造的例子，来具体说明架构的演变过程，让你能更深入地理解架构演变背后的原因。

**V1.0 架构（2012 年）**

接口使用的通信协议是 HTTP+JSON，App 的服务端整体上就一个应用，由移动团队来维护所有对外接口，服务端内部有很多 Jar 包，比如商品搜索、商品详情、购物车等等，这些 Jar 包包含了各个业务线的业务逻辑及数据库访问，它们由各个业务线的开发者负责提供。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062244044.png" alt="image-20220406224408978" style="zoom: 50%;" />

它的优点是简单方便。App 前端的外包团队只需要对接后端的一个移动团队就可以了。

当然也存在了很多问题。

第一个问题：移动服务端对 Jar 包的紧密依赖。在实践中，经常会出现这样的情况：业务团队很多时候，要么忘了同步新的 Jar 包给移动团队，要么是新的 Jar 包调整了类的接口，导致了 App 服务端的功能有问题，或者直接不可用。

第二个问题：移动团队的职责过分复杂。移动团队在 Jar 包的基础上，还需要做很多的业务逻辑聚合。

第三个问题：团队并行开发困难。由于移动团队和业务团队是通过物理 Jar 包进行集成的，移动团队直接受业务团队的代码影响，就导致了团队之间并行开发困难，一次大的 App 升级经常需要 2~3 个月的时间。

**V2.0 架构（2013 年）**

App 前端直接对接多个后端应用提供的 HTTP 接口。移动接口和 Web 应用在同一个工程里开发，作为同一个应用进行部署和运行。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062248612.png" alt="image-20220406224802508" style="zoom: 50%;" />

这实际上就是一种分布式的系统架构，每块业务由不同的团队负责，可以很好地支持团队之间的并行开发。

但这种方式也带来了一系列的问题。

首先是移动端和 PC 端互相干扰的问题。PC 端的代码修改会影响到移动接口，而 Web 应用的发布，也会导致移动接口被动地被发布。

其次是重复开发的问题。安全验证、日志记录、性能监控等等，每个移动接口都需要这些通用功能。

最后是稳定性的问题。基于这种直连方式，只要一个后端系统出问题，就会直接影响到 App 的可用性，使得 App 整体上非常的脆弱。

**V3.0 架构**

在 V3.0 版本中，服务端架构包含了两个大的升级。

首先，将原来大的服务端变成了 3 个应用，包括一个 App 端接口应用，一个 PC 端 Web 应用，还有一个核心业务逻辑服务，3 个部分都是独立维护和部署的。拆分后的架构如下图所示。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062251935.png" alt="image-20220406225145851" style="zoom:50%;" />

除此之外，架构改造还考虑了移动端自身的特点。

一方面，每个移动端接口调用对应的后台服务，这个是个性化的，每个接口的处理逻辑都不一样；另一方面，每个移动端接口都需要进行安全验证、接口监控等。

最后，我们落地了服务端 V3.0 架构。如下图所示。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202204062252109.png" alt="image-20220406225251016" style="zoom:67%;" />

> 这里说明下，当时还没有流行前后端分离，所以 PC 端有对应的 Web 应用，同时负责业务逻辑和 UI 展现。

**移动网关的内部实现**

整个移动网关分为三层，自上而下分别是通用层、接口路由层、适配层，接下来我们逐一分析。

- 通用层

在具体实现时，每个通用功能的处理逻辑都会封装成一个拦截器，这些拦截器遵循统一的接口定义，并且拦截器都是可配置的。

- 接口路由层

我们在配置文件里，对接口请求的 URL 和业务适配器进行映射。配置文件的具体内容如下所示：

```
www.website.com/search SearchAdapter
www.website.com/detail DetailAdapter
```

- 服务适配层

具体到 1 号店当时的情况，外部接口是 HTTP+JSON 格式，内部服务是 Hessian+ 二进制格式。

适配器首先用来解决内外部接口的适配，除此之外，适配器还可以根据需要，对多个内部服务做业务聚合。

> 这样可以对 App 前端提供粗粒度的接口服务，减少远程网络的调用次数。

**架构的实际效果**

第一，App 端和 PC 端彻底独立了。PC 端浏览器有自己的服务端，App 前端也有自己的服务端。可以各自独立地发展了。

第二，通过架构改造，实现了核心业务的复用。在服务设计时，我们不再区分 PC 端还是移动端，而是从业务本身出发，提供一套通用的接口。

第三，这个架构强化了系统级功能。集中式的移动网关统一来提供，我们就可以很方便地强化这些系统级功能。

第四，团队分工也更明确了。移动团队主要负责移动网关，包括网关本身和各种过滤器的维护；业务团队主要负责各自的业务逻辑，包括适配器和底层服务。

# 06 | 可扩展架构案例（三）：你真的需要一个中台吗？

从落地的角度看：

对于互联网企业来说，有大量微服务做基础，往中台转是改良，目的是更好地衔接前台和后台，实现业务的快速创新；

对于传统企业来说，内部有大量的遗留系统，落地中台是革命，目的是盘活老系统，全面实现企业的数字化转型。

# 07 | 可复用架构：如何实现高层次的复用？

**复用的分类**

复用有多种形式，它可以分为技术复用和业务复用两大类。

技术复用包括代码复用和技术组件复用；业务复用包括业务实体复用、业务流程复用和产品复用。

从复用的程度来看，从高到低，我们可以依次划分为产品复用 > 业务流程复用 > 业务实体复用 > 组件复用 > 代码复用。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202206092109115.png" alt="image-20220609210928980" style="zoom:67%;" />

从技术复用到业务复用，越往上，复用程度越高，复用产生的价值也越大，但实现起来也越复杂，它能复用的场景就越有限。

如果我们能进一步打造业务中间件，并在这个基础上，形成业务平台，这样，我们就能实现更高的业务级复用，可以更高效地支持系统的快速落地。

而在实现业务组件化和平台化的过程中，首要的问题就是基础服务边界的划分。

**基础服务边界划分**

这里，我总结了 3 个基础服务边界划分的原则。

首先，是服务的完整性原则。

举个例子，一个商品服务的数据模型，不仅要有商品基本信息，比如商品名称、价格、分类、图片、描述等；还需要包含商品的扩展信息，如商品的各种属性、商品标签等；最后还要包含各种复杂商品类型的定义，比如组合商品、套餐商品、多规格商品等。

另外，你还要保证服务功能的完整性。对于服务使用者来说，他们是以业务的角度看服务，而不是纯粹的数据角度。比如一个套餐商品，在服务内部，它是多个单品的复杂组合，但从服务调用者的角度来看，它就是一个商品。

在实践中，有些服务只是存储基础数据，然后提供简单的增删改查功能，这样一来，服务只是一个简单的 DAO，变成了数据访问通道。这样的服务，它的价值就很有限，也容易被服务调用方质疑。因此，我们要尽可能在服务内部封装完整的业务规则，对外提供完整的业务语义，最大程度地简化服务的使用。

其次，是服务的一致性原则。

服务内部的业务逻辑要尽量依赖内部数据，而不是接口输入的数据，否则会造成数据和业务规则的脱节（一个在外面，一个在里面），如果服务对外部的依赖性很强，就无法提供稳定的能力了。

举个例子，在订单小票上，我们经常能看到一些优惠信息，比如说商品原价是多少，其中因为满减优惠了多少，因为商品特价减免了多少。这个优惠计算的结果是订单的一部分，毫无疑问，它需要保存在订单服务里。

所以在这里，促销服务负责促销规则的维护，以及对应的优惠计算功能；订单服务负责优惠结果数据落地，以及后续的查询功能。这样，每个服务存储的数据和对外提供的功能是一致的。

最后一个，是正交原则。

既然是基础服务，它们就处于调用链的底层，服务之间不会有任何的调用关系，也就是说基础服务相互之间是正交的。比如说会员服务和商品服务，它们代表不同维度的基础业务域，彼此之间不会有调用关系。

正交还有另外一种情况：服务之间有数据的依赖关系，但没有接口的调用关系。

比如说，订单明细里包含商品 ID 信息，但订单服务内部不会调用商品服务来获取商品详情。如果页面需要展示订单的商品详情，针对这个具体的业务场景，我们可以在上层的聚合服务里，通过聚合订单服务和商品服务来实现。

# 08 | 可复用架构案例（一）：如何设计一个基础服务？

对于落地一个共享服务来说，服务边界的划分和功能的抽象设计是核心。服务边界确定了这个服务应该“做什么”，抽象设计确定了这个服务应该“怎么做”。

**订单业务架构**

先介绍下这个订单的业务场景。

这是个 O2O（Online To Offline，线上到线下）的交易业务，订单的来源有两个，一个是自有小程序或 App 过来的订单，还有一个是外卖平台过来的订单。订单的业务架构图如下所示：

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202206112102250.png" alt="image-20220611210210069" style="zoom:67%;" />

在这里，订单服务是和 4 个应用直接打交道的：

- 小程序服务端调用订单服务落地自有线上订单；
- 外卖同步程序接收三方外卖平台的订单，然后调用订单服务落地订单；
- POS 同步程序通过订单服务拉取订单，并推送给商户内部的收银系统；
- 最后还有一个订单管理后台，通过订单服务查询和修改订单。

OK，接下来，我们就具体看下，如何从头开始落地这个订单服务。

**订单服务边界划分**

根据业务场景的分析，这个订单服务需要负责三个方面的功能。

- 基本信息管理

首先是订单基本信息管理，主要提供订单基础信息的增删改查功能，包括下单用户、下单商品、收货人、收货地址、收货时间、堂食或外卖、订单状态、取餐码等。

- 订单优惠管理

然后是订单优惠管理功能，这对应的是订单的小票信息，从最开始的商品金额，到最后需要用户实际支付的金额，中间会有一系列的折扣和减免，这些都是属于订单信息的一部分。这些信息我们需要展示给用户看。

- 订单生命周期管理

最后是订单的生命周期管理功能，主要负责管理订单的状态变化。我们知道，从不同下单渠道过来的订单，它的状态变化过程是不一样的；不同行业的订单，它的状态变化过程也是不同的，所以订单服务的状态要做到通用，能够支持各种可能的状态定义和状态转换过程。

为了更好地定义边界，在实践中，你还需要澄清哪些功能不属于服务。

第一，作为基础服务，订单服务不主动调用其他服务。

第二，订单服务不负责和第三方系统的集成。

第三，订单服务不提供优惠计算或成本分摊逻辑。

最后，该服务不提供履单详情，不负责详细物流信息的存储。

**订单服务内部设计**

作为共享服务，我们要保证订单服务功能上的通用性，就需要同时对内部数据模型和外部接口进行良好的抽象设计。

对于数据模型来说，订单要存储哪些信息，具体可以看下图。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202206112108349.png" alt="image-20220611210830267" style="zoom:67%;" />

**订单状态通用化**

如果针对一个具体的项目，无论它的订单状态有多么的复杂，我们都可以事先精确地定义出来。但不同的行业甚至不同的企业，他们对于订单状态管理都是不一样的，订单服务作为一个共享服务，它必须要满足不同项目的订单状态管理。

对于订单状态管理，可以采用应用和服务各自承担一部分职责处理方式，我们看下具体如何实现。

1. 主状态。

订单一开始都是用户下单后待支付，支付完成后变成一个有效的订单，然后由商家进行接单，制作完成后进行发货配送等等，订单最终的状态要么是完成，要么是取消。

这些订单的基本状态，我们称之为“主状态”，它们由订单服务负责定义。包括这些主状态之间的转换规则，比如已完成的订单不能变为已取消的订单。主状态的数量是比较有限的，状态之间的变化关系也是比较明确的。

<img src="https://technotes.oss-cn-shenzhen.aliyuncs.com/2022/202206112110851.png" alt="image-20220611211025738" style="zoom:67%;" />

2. 子状态。

一个订单处于配送中，实际情况可能是“仓库已发货”，“货已到配送站”，或者是“快递员正在送货中”等等，那么在这些情况中，订单的主状态都是“配送中”，它的子状态就是细化的这几种情况。子状态有哪些具体的取值，不同的项目是不一样的，这个就开放给各个应用来定义。

所以，订单服务数据模型里有两个字段，其中的主状态由订单服务负责管理，包括主状态之间的变化规则；而子状态由上层应用来定义，管理子状态的变化规则，比如一个配送中的订单，它的子状态可以由“仓库已发货”，变为“快递员正在送货中”。

**订单服务接口定义**

外部系统和服务的交互有两种方式，包括同步的服务接口调用和异步的消息通知。

- 括同步的服务接口调用

一个订单有很多字段，每次调用方要查询的信息可能都不相同，不同字段之间的组合方式有很多，我们不可能一一支持。那么，我们怎么设计查询接口，来满足各种场景需求呢? 一般来说，我们可以根据返回字段数量的不同，提供三个不同粒度的查询接口来满足多样化的需求。

第一个是粗粒度接口，只返回订单最基本的 7-8 个字段，比如订单编号、订单状态、订单金额、下单用户、下单时间等等；第二个是中粒度接口，返回订单比较常用的十几个字段；第三个是细粒度接口，返回订单的详细信息。

这样，不同的查询需求，就可以根据要返回信息的详细程度，来选择合适的接口，通过这种方式，我们兼顾了要定义的接口数量和查询的性能。

- 异步的消息通知

按照消息详细程度的不同，订单消息可以分为“胖消息”和“瘦消息”。

胖消息包含了尽可能多的字段，但传输效率低；瘦消息只包含最基本的字段，传输效率高。如果外部系统需要更多的信息，它们可以通过进一步调用订单服务的接口来获取。

在这个订单服务的例子里，如果是订单状态的变化，我们只需提供订单号、变化前后的状态即可，因此主要以瘦消息为主；如果是新订单的创建，由于订单的字段比较多，所以使用胖消息，避免外部系统进一步调用订单服务接口。你在实践中，可以根据实际情况，在消息的数据量和消费者处理消息的复杂度之间做平衡。

# 09 | 可复用架构案例（二）：如何对现有系统做微服务改造？

> 本节内容无需总结。

# 10 | 可复用架构案例（三）：中台是如何炼成的？

> 本节内容无需总结。
